#!/usr/bin/env python3

import os
import re
import subprocess
import sys
import tempfile
from pathlib import Path


def run_git(*args, capture=True, check=True):
    """Run a git command and return stdout."""
    cmd = ["git"] + list(args)
    if capture:
        result = subprocess.run(cmd, capture_output=True, text=True, check=check)
        return result.stdout.strip()
    else:
        subprocess.run(cmd, check=check)


def git_rev_parse(ref):
    """Get the full hash for a reference."""
    return run_git("rev-parse", ref)


def git_rev_parse_short(ref):
    """Get the short hash for a reference."""
    return run_git("rev-parse", "--short", ref)


def usage():
    """Print usage and exit."""
    prog = Path(sys.argv[0]).name
    print(f"Usage:")
    print(f"  {prog} edit HASH")
    print(f"  {prog} reword MESSAGE HASH")
    print(f"  {prog} squash MESSAGE HASH...")
    print(f"  {prog} move REF_HASH HASH...")
    print()
    print(f"Examples:")
    print(f"  {prog} edit HEAD~3")
    print(f"  {prog} reword 'Fix typo in README' abc1234")
    print(f"  {prog} squash 'Combined feature' abc1234 def5678 ghi9012")
    print(f"  {prog} move abc1234 def5678 ghi9012")
    sys.exit(1)


def action_edit(commit):
    """Mark a commit for editing."""
    full = git_rev_parse(commit)
    short = git_rev_parse_short(full)

    editor = f"sed -i -e 's/pick {short}/edit {short}/'"
    env = os.environ.copy()
    env["GIT_SEQUENCE_EDITOR"] = editor

    subprocess.run(["git", "rebase", "-i", f"{full}~1"], env=env, check=True)


def action_reword(message, commit):
    """Reword a commit message."""
    full = git_rev_parse(commit)
    short = git_rev_parse_short(full)

    with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
        f.write(f"""#!/bin/bash
file=$1
if [ -f "$file" ] && grep -q "^#" "$file"; then
    cat > "$file" << 'EOF'
{message}
EOF
fi
""")
        editor_script = f.name

    os.chmod(editor_script, 0o755)

    try:
        sequence_editor = f"sed -i -e 's/pick {short}/reword {short}/'"
        env = os.environ.copy()
        env["GIT_SEQUENCE_EDITOR"] = sequence_editor
        env["GIT_EDITOR"] = editor_script

        subprocess.run(["git", "rebase", "-i", f"{full}~1"], env=env, check=True)
    finally:
        os.unlink(editor_script)


def action_squash(message, *commits):
    """Squash consecutive commits together."""
    if not commits:
        usage()

    full_commits = [git_rev_parse(c) for c in commits]
    short_commits = [git_rev_parse_short(f) for f in full_commits]

    for i in range(len(full_commits) - 1):
        current = full_commits[i]
        next_commit = full_commits[i + 1]

        try:
            run_git("merge-base", "--is-ancestor", next_commit, current)
        except subprocess.CalledProcessError:
            print(f"Error: commits are not in sequence", file=sys.stderr)
            print(f"  {short_commits[i]} is not a descendant of {short_commits[i + 1]}", file=sys.stderr)
            sys.exit(1)

        parent = git_rev_parse(f"{current}~1")
        if parent != next_commit:
            print(f"Error: commits are not consecutive", file=sys.stderr)
            print(f"  {short_commits[i]} and {short_commits[i + 1]} have commits between them", file=sys.stderr)
            sys.exit(1)

    oldest_full = full_commits[-1]

    sed_cmds = [f"-e 's/pick {short}/squash {short}/'" for short in short_commits[:-1]]
    sequence_editor = "sed -i " + " ".join(sed_cmds)

    with tempfile.NamedTemporaryFile(mode='w', suffix='.sh', delete=False) as f:
        f.write(f"""#!/bin/bash
file=$1
if [ -f "$file" ] && grep -q "^#" "$file"; then
    first_line=$(head -1 "$file")
    if echo "$first_line" | grep -q "^# This is a combination of"; then
        cat > "$file.new" << 'EOF'
{message}
EOF
        grep "^#" "$file" >> "$file.new"
        mv "$file.new" "$file"
    fi
fi
""")
        editor_script = f.name

    os.chmod(editor_script, 0o755)

    try:
        env = os.environ.copy()
        env["GIT_SEQUENCE_EDITOR"] = sequence_editor
        env["GIT_EDITOR"] = editor_script

        subprocess.run(["git", "rebase", "-i", f"{oldest_full}~1"], env=env, check=True)
    finally:
        os.unlink(editor_script)


def action_move(ref_hash, *move_hashes):
    """Move commits to appear after a reference commit."""
    if not move_hashes:
        usage()

    ref_full = git_rev_parse(ref_hash)
    ref_short = git_rev_parse_short(ref_full)

    move_full = [git_rev_parse(h) for h in move_hashes]
    move_short = [git_rev_parse_short(f) for f in move_full]

    all_commits = [ref_full] + move_full
    base = run_git("merge-base", "--octopus", *all_commits)

    with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
        f.write(f"""#!/usr/bin/env python3
import sys

ref_short = {ref_short!r}
move_shorts = {move_short!r}

with open(sys.argv[1], 'r') as f:
    lines = f.readlines()

ref_line = None
ref_index = None
move_lines = {{}}
other_lines = []

for i, line in enumerate(lines):
    if line.startswith('pick '):
        hash_match = line.split()[1] if len(line.split()) > 1 else None
        if hash_match == ref_short:
            ref_line = line
            ref_index = len(other_lines)
            other_lines.append(line)
        elif hash_match in move_shorts:
            move_lines[hash_match] = line
        else:
            other_lines.append(line)
    else:
        other_lines.append(line)

if ref_line is None:
    print(f"Error: reference commit {{ref_short}} not found in rebase todo", file=sys.stderr)
    sys.exit(1)

for short in move_shorts:
    if short not in move_lines:
        print(f"Error: commit {{short}} not found in rebase todo", file=sys.stderr)
        sys.exit(1)

result = other_lines[:ref_index + 1]
for short in move_shorts:
    result.append(move_lines[short])
result.extend(other_lines[ref_index + 1:])

with open(sys.argv[1], 'w') as f:
    f.writelines(result)
""")
        editor_script = f.name

    os.chmod(editor_script, 0o755)

    try:
        env = os.environ.copy()
        env["GIT_SEQUENCE_EDITOR"] = editor_script

        subprocess.run(["git", "rebase", "-i", base], env=env, check=True)
    finally:
        os.unlink(editor_script)


def main():
    if len(sys.argv) < 3:
        usage()

    action = sys.argv[1]
    args = sys.argv[2:]

    if action == "edit":
        if len(args) != 1:
            usage()
        action_edit(args[0])

    elif action == "reword":
        if len(args) != 2:
            usage()
        action_reword(args[0], args[1])

    elif action == "squash":
        if len(args) < 2:
            usage()
        action_squash(args[0], *args[1:])

    elif action == "move":
        if len(args) < 2:
            usage()
        action_move(args[0], *args[1:])

    else:
        usage()


if __name__ == "__main__":
    main()
