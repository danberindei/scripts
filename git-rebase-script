#!/usr/bin/env python3

import os
import shlex
import subprocess
import sys
from pathlib import Path


SCRIPT_PATH = os.path.abspath(sys.argv[0])


def run_git(*args, capture=True, check=True):
    """Run a git command and return stdout."""
    cmd = ["git"] + list(args)
    if capture:
        result = subprocess.run(cmd, capture_output=True, text=True, check=check)
        return result.stdout.strip()
    else:
        subprocess.run(cmd, check=check)


def git_rev_parse(ref):
    """Get the full hash for a reference."""
    return run_git("rev-parse", ref)


def git_rev_parse_short(ref):
    """Get the short hash for a reference."""
    return run_git("rev-parse", "--short", ref)


def usage():
    """Print usage and exit."""
    prog = Path(sys.argv[0]).name
    print(f"Usage:")
    print(f"  {prog} edit HASH")
    print(f"  {prog} reword MESSAGE HASH")
    print(f"  {prog} squash MESSAGE HASH...")
    print(f"  {prog} move REF_HASH HASH...")
    print()
    print(f"Examples:")
    print(f"  {prog} edit HEAD~3")
    print(f"  {prog} reword 'Fix typo in README' abc1234")
    print(f"  {prog} squash 'Combined feature' abc1234 def5678 ghi9012")
    print(f"  {prog} move abc1234 def5678 ghi9012")
    sys.exit(1)


def editor_reword(filepath, message):
    """Editor function for reword: replace commit message."""
    with open(filepath, 'r') as f:
        content = f.read()

    if content:
        with open(filepath, 'w') as f:
            f.write(message + '\n')


def editor_squash(filepath, message):
    """Editor function for squash: replace combined commit message."""
    with open(filepath, 'r') as f:
        lines = f.readlines()

    if lines and lines[0].startswith('# This is a combination of'):
        with open(filepath, 'w') as f:
            f.write(message + '\n')
            for line in lines:
                if line.startswith('#'):
                    f.write(line)


def editor_move(filepath, ref_short, move_shorts):
    """Editor function for move: reorder commits in todo."""
    with open(filepath, 'r') as f:
        lines = f.readlines()

    ref_line = None
    ref_index = None
    move_lines = {}
    other_lines = []

    for line in lines:
        if line.startswith('pick '):
            parts = line.split()
            hash_match = parts[1] if len(parts) > 1 else None
            if hash_match == ref_short:
                ref_line = line
                ref_index = len(other_lines)
                other_lines.append(line)
            elif hash_match in move_shorts:
                move_lines[hash_match] = line
            else:
                other_lines.append(line)
        else:
            other_lines.append(line)

    if ref_line is None:
        print(f"Error: reference commit {ref_short} not found in rebase todo", file=sys.stderr)
        sys.exit(1)

    for short in move_shorts:
        if short not in move_lines:
            print(f"Error: commit {short} not found in rebase todo", file=sys.stderr)
            sys.exit(1)

    result = other_lines[:ref_index + 1]
    for short in move_shorts:
        result.append(move_lines[short])
    result.extend(other_lines[ref_index + 1:])

    with open(filepath, 'w') as f:
        f.writelines(result)


def action_edit(commit):
    """Mark a commit for editing."""
    full = git_rev_parse(commit)
    short = git_rev_parse_short(full)

    editor = f"sed -i -e 's/^pick {short}/edit {short}/'"
    env = os.environ.copy()
    env["GIT_SEQUENCE_EDITOR"] = editor

    subprocess.run(["git", "rebase", "-i", f"{full}~1"], env=env, check=True)


def action_reword(message, commit):
    """Reword a commit message."""
    full = git_rev_parse(commit)
    short = git_rev_parse_short(full)

    sequence_editor = f"sed -i -e 's/^pick {short}/reword {short}/'"
    git_editor = f"{shlex.quote(SCRIPT_PATH)} --editor-reword {shlex.quote(message)}"

    env = os.environ.copy()
    env["GIT_SEQUENCE_EDITOR"] = sequence_editor
    env["GIT_EDITOR"] = git_editor

    subprocess.run(["git", "rebase", "-i", f"{full}~1"], env=env, check=True)


def action_squash(message, *commits):
    """Squash consecutive commits together."""
    if not commits:
        usage()

    full_commits = [git_rev_parse(c) for c in commits]
    short_commits = [git_rev_parse_short(f) for f in full_commits]

    for i in range(len(full_commits) - 1):
        current = full_commits[i]
        next_commit = full_commits[i + 1]

        try:
            run_git("merge-base", "--is-ancestor", next_commit, current)
        except subprocess.CalledProcessError:
            print(f"Error: commits are not in sequence", file=sys.stderr)
            print(f"  {short_commits[i]} is not a descendant of {short_commits[i + 1]}", file=sys.stderr)
            sys.exit(1)

        parent = git_rev_parse(f"{current}~1")
        if parent != next_commit:
            print(f"Error: commits are not consecutive", file=sys.stderr)
            print(f"  {short_commits[i]} and {short_commits[i + 1]} have commits between them", file=sys.stderr)
            sys.exit(1)

    oldest_full = full_commits[-1]

    sed_cmds = [f"-e 's/^pick {short}/squash {short}/'" for short in short_commits[:-1]]
    sequence_editor = "sed -i " + " ".join(sed_cmds)
    git_editor = f"{shlex.quote(SCRIPT_PATH)} --editor-squash {shlex.quote(message)}"

    env = os.environ.copy()
    env["GIT_SEQUENCE_EDITOR"] = sequence_editor
    env["GIT_EDITOR"] = git_editor

    subprocess.run(["git", "rebase", "-i", f"{oldest_full}~1"], env=env, check=True)


def action_move(ref_hash, *move_hashes):
    """Move commits to appear after a reference commit."""
    if not move_hashes:
        usage()

    if len(move_hashes) != len(set(move_hashes)):
        print(f"Error: duplicate hashes in move list", file=sys.stderr)
        sys.exit(1)

    ref_full = git_rev_parse(ref_hash)
    ref_short = git_rev_parse_short(ref_full)

    move_full = [git_rev_parse(h) for h in move_hashes]
    move_short = [git_rev_parse_short(f) for f in move_full]

    if len(move_short) != len(set(move_short)):
        print(f"Error: duplicate commits after resolving hashes", file=sys.stderr)
        sys.exit(1)

    try:
        base = git_rev_parse(f"{ref_full}~1")
    except subprocess.CalledProcessError:
        print(f"Error: reference commit has no parent (root commit)", file=sys.stderr)
        sys.exit(1)

    editor_args = [shlex.quote(SCRIPT_PATH), '--editor-move', shlex.quote(ref_short)]
    editor_args.extend(shlex.quote(s) for s in move_short)
    sequence_editor = ' '.join(editor_args)

    env = os.environ.copy()
    env["GIT_SEQUENCE_EDITOR"] = sequence_editor

    subprocess.run(["git", "rebase", "-i", base], env=env, check=True)


def main():
    if len(sys.argv) < 2:
        usage()

    if sys.argv[1] == "--editor-reword":
        if len(sys.argv) != 4:
            sys.exit(1)
        editor_reword(sys.argv[3], sys.argv[2])
        return

    if sys.argv[1] == "--editor-squash":
        if len(sys.argv) != 4:
            sys.exit(1)
        editor_squash(sys.argv[3], sys.argv[2])
        return

    if sys.argv[1] == "--editor-move":
        if len(sys.argv) < 4:
            sys.exit(1)
        ref_short = sys.argv[2]
        move_shorts = sys.argv[3:-1]
        filepath = sys.argv[-1]
        editor_move(filepath, ref_short, move_shorts)
        return

    if len(sys.argv) < 3:
        usage()

    action = sys.argv[1]
    args = sys.argv[2:]

    if action == "edit":
        if len(args) != 1:
            usage()
        action_edit(args[0])

    elif action == "reword":
        if len(args) != 2:
            usage()
        action_reword(args[0], args[1])

    elif action == "squash":
        if len(args) < 2:
            usage()
        action_squash(args[0], *args[1:])

    elif action == "move":
        if len(args) < 2:
            usage()
        action_move(args[0], *args[1:])

    else:
        usage()


if __name__ == "__main__":
    main()
