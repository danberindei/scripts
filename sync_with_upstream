#!/usr/bin/env python
# -*- coding: utf-8 -*-
#
############################################################################
#
# Name: sync_with_upstream
# Author: Manik Surtani (http://github.com/maniksurtani)
#         Galder ZamarreÃ±o (http://github.com/galderz)
#         Dan Berindei (http://github.com/danberindei)
# Description: This script updates a fork of an upstream repository with new
#              changes in the upstream.  It is designed to be run on a local
#              clone of the fork.  In addition to updating necessary branches,
#              the script also rebases any topic branches that may exist.
#
# Configuration: The following variables need to be set.


DEFAULT_UPSTREAM_REPO="upstream" # Can be a named remote, or a full URL, such as https://github.com/infinispan/infinispan
ORIGIN_REPO="origin" # The fork of upstream.  Can be a named remote or a full URL.
DEFAULT_TOPIC_BRANCH_PREFIX="t_" # All branches whose name starts with this will be rebased against their updated branch point
GIT="git" # Path to the git binary executable

CONFIG_UPSTREAM_REPO="sync.upstreamRepo"
CONFIG_RELEASE_BRANCHES="sync.releaseBranches"
CONFIG_TOPIC_BRANCH_PREFIX="sync.topicBranchPrefix"
CONFIG_MIRROR_MASTER_TO_MAIN="sync.mirrorMasterToMain"

#
############################################################################

import os
from os import path
import sys
import subprocess
import getopt

isdebug = False
push_to_origin = False
upstream_repo = None
release_branches = None
topic_branch_prefix = None
checked_out_branch = None

def run_git(opts):
  if isdebug:
    print("### git %s" % opts)

  call = [GIT]
  for o in opts.split(' '):
    if o != '':
      call.append(o)
  result = subprocess.run(call, capture_output=True, text=True)
  if result.returncode == 0:
    return result.stdout
  else:
    raise Exception("Error running 'git %s':\n%s" % (opts, result.stderr))

def init():
  global checked_out_branch
  # Cache current branch to be able to get it back to it after done
  #checked_out_branch = run_git("symbolic-ref --short HEAD").split('\n')[0]
  checked_out_branch = run_git("symbolic-ref HEAD").replace("refs/heads/", "").split('\n')[0]

  if not os.path.isdir(".git"):
    print("This script MUST be run in the local clone of your forked repo!")
    sys.exit(1)

  if have_local_changes():
    print("Stashing local changes")
    try:
        run_git("stash save 'sync_with_upstream backup'")
    except:
        exit(1)

  print("Fetching new details from %s" % upstream_repo)
  run_git("fetch %s" % upstream_repo)
  run_git("fetch %s --tags" % upstream_repo)

def finish():
  run_git("checkout -q %s" % checked_out_branch)
  stashes = run_git("stash list --format='%s'")
  if len(stashes) > 0 and ("sync_with_upstream backup" in stashes):
    try:
        run_git("stash pop")
    except:
        pass

def have_local_changes():
  output = run_git("status --porcelain --untracked-files=no")
  return output != ""

def is_push_needed(branch):
  if not push_to_origin:
    return False

  try:
    return is_rebase_needed("origin/%s" % branch, branch)
  except Exception:
    return True

def is_rebase_needed(branch, release_branch):
  upstream_only_commit = run_git("rev-list --cherry --right-only --max-count=1 %s..%s" % (branch, release_branch))
  return upstream_only_commit != ''

def mirror_master_to_main():
  should_mirror = run_git("config get --default=false %s" % CONFIG_MIRROR_MASTER_TO_MAIN).strip()
  if should_mirror == "true":
    print("Synchronizing master to main")
    run_git("checkout --ignore-other-worktrees -q main")
    run_git("reset --hard master")

def handle_release_branches():
  #print("Release branches are %s" % branches)
  for relbranch in release_branches:
    if is_rebase_needed(relbranch, upstream_repo + "/" + relbranch):
      print("Synchronizing release branch %s" % relbranch)
      run_git("checkout --ignore-other-worktrees -q %s" % relbranch)
      try:
        run_git("rebase -q %s/%s" % (upstream_repo, relbranch))
      except:
        print("Rebase on upstream failed for %s" % relbranch)
        sys.exit(3)
    else:
      #print("Branch %s hasn't changed upstream" % branch)
      pass

    if upstream_repo != ORIGIN_REPO:
      run_git("push -q -f %s %s" % (ORIGIN_REPO, relbranch))

  if upstream_repo != ORIGIN_REPO:
    run_git("push -q %s --tags" % ORIGIN_REPO)

def handle_topics():
  print("Release branches are %s" % release_branches)
  ## Now handle topic branches.
  b = run_git("for-each-ref --format=%(refname:short) refs/heads/**")
  topic_branches = [tb for tb in b.splitlines() if tb.startswith(topic_branch_prefix)]
  print("Branches are %s " % topic_branches)

  base_branches = dict()
  for topic_branch in topic_branches:
    if isdebug: print("Analysing topic branch %s" % (topic_branch))

    #read the upstream branch from config
    base_branch = ""
    base_distance = 500
    try:
      # git rev-parse --symbolic-full-name ISPN-10029_remove_TxPutForLoadValidatorInterceptor@{upstream}
      base_branch = run_git("rev-parse --symbolic-full-name %s@{upstream}" % (topic_branch)).strip()
      base_distance = int(run_git("rev-list --max-count=%s --count %s..%s" % (base_distance, base_branch, topic_branch)))
      if isdebug: print("Current upstream is %s, distance is %s" % (base_branch, base_distance))
      if base_branch not in release_branches: base_distance = 99
    except:
      print("Unable to read upstream distance for topic branch %s" % (topic_branch))

    min_branch = base_branch
    min_distance = base_distance
    for relbranch in release_branches:
      distance = int(run_git("rev-list --max-count=%s --count %s/%s..%s" % (min_distance, upstream_repo, relbranch, topic_branch)))
      # if isdebug: print("Possible base branch %s, distance is %s" % (relbranch, distance))
      if distance < min_distance:
        min_branch = relbranch
        min_distance = distance
      if distance == 0:
        break

    if min_distance < base_distance:
      if base_branch == '':
        print("Set upstream branch for %s: %s, distance is %s" % (topic_branch, min_branch, min_distance))
        run_git(f"config set branch.{topic_branch}.pushRemote {ORIGIN_REPO}")
        run_git(f"config set branch.{topic_branch}.remote {upstream_repo}")
        run_git(f"config set branch.{topic_branch}.merge refs/heads/{min_branch}")
        run_git("branch --set-upstream-to=%s %s" % (min_branch, topic_branch))
      else:
        print("Found better upstream branch for %s: %s, distance is %s, base branch %s, base distance %d" % (topic_branch, min_branch, min_distance, base_branch, base_distance))
    elif not (base_branch in release_branches):
      print("Using branch %s as base of branch %s" % (min_branch, topic_branch))

    base_branches[topic_branch] = min_branch

  # First, topic branches that are based directly on a release branch
  for branch, base_branch in base_branches.items():
    if base_branch in release_branches:
      rebase_topic_branch(branch, base_branch)

  # Then topic branches that are based on other topic branches
  for branch, base_branch in base_branches.items():
    if not base_branch in release_branches:
      rebase_topic_branch(branch, base_branch)

  # Finally, push the modified branches to origin
  for branch in topic_branches:
    push_topic_branch(branch)

def rebase_topic_branch(branch, base_branch):
  if is_rebase_needed(branch, base_branch):
    print("Rebasing topic branch %s on top of %s" % (branch, base_branch))
    run_git("checkout --ignore-other-worktrees %s" % branch)
    try:
      #run_git("rebase %s" % base_branch)
      run_git("merge %s" % base_branch)
    except:
      print("Rebase on upstream (%s) failed for %s" % (base_branch, branch))
      sys.exit(3)
  else:
    #print("Rebase not necessary for topic branch %s" % branch)
    pass

def push_topic_branch(branch):
  if upstream_repo != ORIGIN_REPO and is_push_needed(branch):
    print("Pushing branch %s to %s" % (branch, ORIGIN_REPO))
    try:
      # This will fail if the remote branch doesn't exist yet
      run_git("push -q --force-with-lease %s %s" % (ORIGIN_REPO, branch))
    except Exception:
      run_git("push -q %s %s" % (ORIGIN_REPO, branch))
  else:
    pass

def is_not_empty(n):
 return n != ''

def parse_args():
  global upstream_repo
  global release_branches
  global isdebug
  global push_to_origin
  global topic_branch_prefix
  try:
    opts, args = getopt.getopt(sys.argv[1:], "hdpu:b:", ["help", "debug", "push", "upstream=", "branches="])
  except getopt.GetoptError as err:
    # print help information and exit:
    print(str(err)) # will print something like "option -a not recognized"
    sys.exit(2)

  upstream_repo = run_git(f"config get --default={DEFAULT_UPSTREAM_REPO} {CONFIG_UPSTREAM_REPO}").strip()
  if upstream_repo == "":
    upstream_repo = DEFAULT_UPSTREAM_REPO

  release_branches = run_git("config get %s" % CONFIG_RELEASE_BRANCHES).split()
  if release_branches == "":
    print("Please configure release branches with %s" % CONFIG_RELEASE_BRANCHES)

  try:
    topic_branch_prefix = run_git("config get %s" % CONFIG_TOPIC_BRANCH_PREFIX).strip()
  except Exception:
    topic_branch_prefix = DEFAULT_TOPIC_BRANCH_PREFIX

  for o, a in opts:
    if o in ("-p", "--push"):
      push_to_origin = True
    elif o in ("-h", "--help"):
      usage()
      sys.exit()
    elif o in ("-d", "--debug"):
      isdebug = True
    else:
      assert False, "unhandled option"

def usage():
  print("usage: ", sys.argv[0],"[-u <upstream repo>] [-b <comma separated branches>] [-p]")

def main():
  parse_args()
  init()
  handle_release_branches()
  mirror_master_to_main()
  print("Local release branches %s synced with %s" % (release_branches, upstream_repo))
  print("Now rebasing all topic branches that start with '%s'" % topic_branch_prefix)
  handle_topics()
  finish()

if __name__ == "__main__":
  main()
